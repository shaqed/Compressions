import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;

public class BurrowsWheeler {
    
    public static boolean verbose = true; // True for verbose mode


    /**
     *
     * Encodes a string using the Burrows Wheeler algorithm
     *
     * No return because you need to return array L and X
     * (Modify this as you wish)
     *
     * @param str String to be encoded
     *
     * */
    public static void encode(String str) {

        println("Burrows Wheeler Algorithm");
        ArrayList<String> transformations = new ArrayList<>(str.length());
        // Transform str
        for (int i = 0; i < str.length(); i++) {
            StringBuilder stringBuilder = new StringBuilder();
            for (int j = 0; j < str.length(); j++) {
                print(str.charAt((i+j)%str.length()));
                stringBuilder.append(str.charAt((i+j)%str.length()));
            }
            transformations.add(stringBuilder.toString());

            println();
        }

        println("\nSorted");
        Collections.sort(transformations);
        for (String i : transformations) {
            println(i);
        }

        println("\nLast Column L:");
        StringBuilder stringBuilder = new StringBuilder();
        int X = 0;
        for(int i = 0; i < transformations.size(); i++) {
            String runnerString = transformations.get(i);
            stringBuilder.append(runnerString.charAt(runnerString.length()-1)); // get last index of every string
            if (runnerString.equals(str)) {
                X = i;
            }
        }
        String L = stringBuilder.toString();
        println(L);

        println("Value of X: " + X); // The index of the original string AFTER the alphabetical sort

        decode(L, X);
    }



    /**
     * Decodes the string with the Burrows Wheeler algorithm
     *  @param L The array/string generated by the encode() method
     * @param X The X value generated by encoding the string
     *
     * */
    public static String decode(String L, int X) {

        // Create F
        char[] LArray = L.toCharArray();
        char[] F = L.toCharArray();
        Arrays.sort(F);
        String fString = new String(F);

        println("F: " + fString);

        int [] T = new int[L.length()];
        for (int i = 0; i < F.length; i++) {
            for (int j = 0; j < L.length(); j++) {
                if (F[i] == LArray[j]){
                    T[i] = j;
                    LArray[j] = 0;
                    break;
                }

            }
        }
        println("T: " + Arrays.toString(T));

        // Now translate
        int i = -1;
        for (int j = 0; j < T.length; j++) {
            if (T[j] == X){
                i = j;
                break;
            }
        }

        println("Starting index: " + i);
        StringBuilder stringBuilder = new StringBuilder();

        int startI = i;
        do {
            int runningIndex = T[i];
            print(F[runningIndex]);

            stringBuilder.append(F[runningIndex]);

            i = T[i];

        } while (i != startI);
        println();


        return stringBuilder.toString();
    }



    private static void println() {
        if (verbose) {
            System.out.println();
        }
    }
    private static void println(String msg) {
        if (verbose) {
            System.out.println(msg);
        }
    }
    private static void println(int n) {
        if (verbose) {
            System.out.println(n);
        }
    }


    private static void print(String msg) {
        if (verbose) {
            System.out.print(msg);
        }
    }
    private static void print(int n) {
        if (verbose) {
            System.out.print(n);
        }
    }
    private static void print(char n) {
        if (verbose) {
            System.out.print(n);
        }
    }
}
